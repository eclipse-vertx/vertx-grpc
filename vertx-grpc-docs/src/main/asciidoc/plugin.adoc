[[vertx-grpc-protoc-plugin]]
== Vert.x gRPC Protoc Plugin 2

The easiest way to start using Vert.x gRPC is to utilize its built-in code generator plugin. To do so,
one must define the protocol in the `protobuffer` format as required by gRPC.

[source,proto]
----
syntax = "proto3";

option java_multiple_files = true;
option java_package = "examples";
option java_outer_classname = "HelloWorldProto";
package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
----

This is a very simple example showing the single request, single response mode.

=== Compile the RPC definition

Using the definition above we need to compile it.

You can compile the proto file using the `protoc` compiler if you https://github.com/google/protobuf/tree/master/java#installation---without-maven[like], or you can integrate it in your build.

If you're using Apache Maven you can choose from 2 plugins `io.github.ascopes:protobuf-maven-plugin` (Recommended) or `org.xolstice.maven.plugin:protobuf-maven-plugin`:

[source,xml]
----
<plugin>
    <groupId>io.github.ascopes</groupId>
    <artifactId>protobuf-maven-plugin</artifactId>
    <version>${ascopes.grpc.version}</version>
    <configuration>
        <protocVersion>${protobuf.version}</protocVersion>
    </configuration>
    <executions>
        <execution>
            <id>compile-java</id>
            <configuration>
                <jvmMavenPlugins>
                    <jvmMavenPlugin>
                        <groupId>io.vertx</groupId>
                        <artifactId>vertx-grpc-protoc-plugin2</artifactId>
                        <version>${vertx.version}</version>
                        <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
                        <options>grpc-client=true,grpc-service=true,grpc-io=true</options>
                        <!-- OR You can use jvmArgs -->
                        <jvmArgs>
                            <jvmArg>--grpc-client=true</jvmArg>
                            <jvmArg>--grpc-service=true</jvmArg>
                            <jvmArg>--grpc-io=true</jvmArg>
                        </jvmArgs>
                    </jvmMavenPlugin>
                </jvmMavenPlugins>
            </configuration>
        </execution>
    </executions>
</plugin>
----

This plugin uses `protocVersion` instead of platform-specific artifacts and takes care of downloading protoc based on your platform and version on its own.

For more details, see the https://ascopes.github.io/protobuf-maven-plugin/[ascopes protobuf-maven-plugin documentation].

[source,xml]
----
<plugin>
    <groupId>org.xolstice.maven.plugins</groupId>
    <artifactId>protobuf-maven-plugin</artifactId>
    <version>0.6.1</version>
    <configuration>
        <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
        <protocPlugins>
            <protocPlugin>
                <id>vertx-grpc-protoc-plugin2</id>
                <groupId>io.vertx</groupId>
                <artifactId>vertx-grpc-protoc-plugin2</artifactId>
                <version>${stack.version}</version>
                <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
                <args>
                    <arg>--grpc-client=true</arg>
                    <arg>--grpc-service=true</arg>
                    <arg>--grpc-io=true</arg>
                </args>
            </protocPlugin>
        </protocPlugins>
    </configuration>
    <executions>
        <execution>
            <id>compile</id>
            <configuration>
                <outputDirectory>${project.basedir}/src/main/java</outputDirectory>
                <clearOutputDirectory>false</clearOutputDirectory>
            </configuration>
            <goals>
                <goal>compile</goal>
                <goal>compile-custom</goal>
            </goals>
        </execution>
    </executions>
</plugin>
----

NOTE: The `org.xolstice.maven.plugin:protobuf-maven-plugin` is no longer supported as per https://github.com/xolstice/protobuf-maven-plugin/issues/121#issuecomment-2832430955. Users are encouraged to use `io.github.ascopes:protobuf-maven-plugin` instead.

For more details, see the https://www.xolstice.org/protobuf-maven-plugin/[xolstice protobuf-maven-plugin documentation].

The `${os.detected.classifier}` property is used to make the build OS independent, on OSX it is replaced
by _osx-x86_64_ and so on. To use it you need to add the os-maven-plugin[https://github.com/trustin/os-maven-plugin]
in the `build` section of your `pom.xml`:

[source,xml]
----
<build>
  ...
  <extensions>
    <extension>
      <groupId>kr.motd.maven</groupId>
      <artifactId>os-maven-plugin</artifactId>
      <version>1.4.1.Final</version>
    </extension>
  </extensions>
  ...
</build>
----

This plugin will compile your proto files under `src/main/proto` and make them available to your project.

By default, the plugin generates both client and service files. If you need only one side you can configure the generator to generate only a specific class:

[source,xml]
----
<jvmMavenPlugin>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-protoc-plugin2</artifactId>
  <version>${vertx.version}</version>
  <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
  <options>grpc-client=true,grpc-service=true,grpc-io=true</options>
</jvmMavenPlugin>
----

=== Arguments:

- _[--]grpc-client[=true/false]_: generate the client files
- _[--]grpc-service[=true/false]_: generate the service files
- _[--]grpc-io[=true/false]_: generate stub files compatible with `io.grpc:grpc-stub`, not generated by default. When using this option, you must also ensure the grpc-java plugin is configured (as shown in the Maven configuration above)
- _[--]grpc-transcoding[=true/false]_: whether to generate transcoding options for methods with HTTP annotations
- _[--]vertx-codegen[=true/false]_: whether to add Vert.x annotations to the generated classes (`@VertxGen`) By default, this is disabled
- _[--]service-prefix[=Your Name]_: generate service classes with a prefix. For example, if you set it to `MyService`, the generated service class will be `MyServiceGreeterService` instead of `GreeterService`.
- _[--]schema-output-format[=openapi-json+openapi-yaml]_: generate OpenAPI specification files. Use `openapi-json` for JSON format, `openapi-yaml` for YAML format, or combine both with `+` (e.g., `openapi-json+openapi-yaml`). Not generated by default.
- _[--]schema-allow-merge[=true/false]_: when generating OpenAPI specs, merge all services into a single file (`openapi.json`/`openapi.yaml`). When set to `false`, generates separate files per service (`ServiceName-openapi.json`/`ServiceName-openapi.yaml`). Default is `true`.
- _[--]schema-config[=/path/to/config.yaml]_: path to an OpenAPI configuration file (YAML or JSON) that customizes the generated specification. The config file can override info, servers, security, tags, externalDocs, and add securitySchemes. See <<openapi-configuration-file>> for details.

* [--] This means the argument can be prefixed with `--` when used as JVM arguments, but should be used without `--` when specified in the options tag. If possible, users should use plugin options as a more universal protoc plugin approach.
* [=value] This means the argument can optionally specify a value. For boolean arguments (true/false), if no value is specified, the default is `true` when the argument is present. For string arguments like `service-prefix`, a value must be provided.

If no specific generation options are provided, both client and service files will be generated by default. By default, all extensions (currently only 'http') are supported.

=== OpenAPI Specification Generation

The plugin can generate OpenAPI 3.0 specification files from your gRPC service definitions. This is useful when using <<grpc-transcoding,gRPC transcoding>> to expose your services as REST APIs.

OpenAPI specs are generated for services that have HTTP annotations (`google.api.http`). Services and methods without HTTP annotations are skipped.

= OpenAPI specification generation

The plugin generates OpenAPI 3.0 specification files from your gRPC service definitions. This is useful when you use <<grpc-transcoding,gRPC transcoding>> to expose services as REST APIs.

The plugin only generates specs for services with HTTP annotations (`google.api.http`).

== Enabling OpenAPI generation

To start generating specs, add the `schema-output-format` option to your plugin configuration:

[source,xml]
----
<jvmMavenPlugin>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-protoc-plugin2</artifactId>
  <version>${vertx.version}</version>
  <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
  <options>grpc-client=true,grpc-service=true,schema-output-format=openapi-json+openapi-yaml</options>
</jvmMavenPlugin>
----

== Output formats

The plugin supports two formats:

* `openapi-json`: Generates a `.json` file.
* `openapi-yaml`: Generates a `.yaml` file.

To generate both at once, combine them with a `+` symbol:
`schema-output-format=openapi-json+openapi-yaml`

== Merge vs split mode

By default, the plugin combines all services into a single OpenAPI file (`openapi.json` or `openapi.yaml`). If you prefer a separate file for each service, set `schema-allow-merge` to `false`.

=== Merge mode (default)
All services are bundled into one file.

[source]
----
schema-allow-merge=true
----

=== Split mode
Each service gets its own file, such as `GreeterService-openapi.json` or `AnotherService-openapi.yaml`.

[source]
----
schema-allow-merge=false
----

[[openapi-configuration-file]]
== Configuration file

You can customize the output by providing a YAML or JSON configuration file. This allows you to set or override these fields:

* `info`: API metadata like title, version, and contact info.
* `servers`: Target server URLs.
* `security`: Global security requirements.
* `tags`: Tag definitions.
* `externalDocs`: Links to outside documentation.
* `components.securitySchemes`: Security scheme definitions.

.Example configuration (openapi-config.yaml)
[source,yaml]
----
openapi: 3.0.0
info:
  title: My Greeting API
  version: 2.0.0
  description: A greeting service
  contact:
    name: API Support
    email: support@example.com
servers:
  - url: https://api.example.com
    description: Production
security:
  - bearerAuth: []
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
----

=== Using the configuration file

[source,xml]
----
<jvmMavenPlugin>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-protoc-plugin2</artifactId>
  <version>${vertx.version}</version>
  <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
  <options>schema-output-format=openapi-json,schema-config=${project.basedir}/openapi-config.yaml</options>
</jvmMavenPlugin>
----

The plugin merges your configuration with the generated spec using these rules:

1. Values in `info`, `servers`, `security`, `tags`, and `externalDocs` *replace* whatever the plugin generates.
2. Values in `components.securitySchemes` are *added* to the generated schemas.
3. The plugin always preserves the generated `paths` and `components.schemas`. Your config file cannot override these.

== Example

If you have a proto file with HTTP annotations like this:

[source,proto]
----
syntax = "proto3";
import "google/api/http.proto";
option java_package = "examples";

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {
    option (google.api.http) = {
      post: "/v1/hello"
      body: "*"
      additional_bindings {
        get: "/v1/hello/{name}"
      }
    };
  }
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
----

The plugin produces an OpenAPI spec for the `/v1/hello` endpoints, including the request and response schemas. You can find the output in the protobuf output root folder.

If you're using Gradle you need to add the plugin:

[source,groovy]
----
...
apply plugin: 'com.google.protobuf'
...
buildscript {
  ...
  dependencies {
    // ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
  }
}
...
protobuf {
  protoc {
    artifact = 'com.google.protobuf:protoc:3.2.0'
  }
  plugins {
    grpc {
      artifact = "io.grpc:protoc-gen-grpc-java:1.25.0"
    }
    vertx {
      artifact = "io.vertx:vertx-grpc-protoc-plugin2:${vertx.grpc.version}"
    }
  }
  generateProtoTasks {
    all()*.plugins {
      grpc
      vertx
    }
  }
}
----

This plugin will compile your proto files under `build/generated/source/proto/main` and make them available to your project.

NOTE: the generator plugin is tech preview and can be subject to changes

=== Generated RPC files

For each service definition (e.g., `Greeter`), the plugin creates several Java RPC files with specific purposes:

[cols="2,4,1", options="header"]
|===
|Generated File |Description |Details

|`Greeter.java`
|Base interface defining the service contract with all RPC methods declared as abstract methods
|Common to both client and server

|`GreeterClient.java`
|High-level client interface with idiomatic Vert.x Future-based methods for calling the service
|<<idiomatic-client,Client API>>

|`GreeterService.java`
|High-level server interface for implementing the service with idiomatic Vert.x Future-based handlers
|<<idiomatic-server,Server Stub>>

|`GreeterGrpcClient.java`
|Low-level client implementation providing direct access to gRPC request/response streams
|<<client-request-response-api,Client Request/Response API>>

|`GreeterGrpcService.java`
|Low-level server implementation providing direct access to gRPC request/response streams for handling
|<<server-request-response-api,Server Request/Response API>>
|===

NOTE: The `GreeterGrpcClient` and `GreeterGrpcService` classes provide lower-level APIs that give you more control over streaming and flow control, while `GreeterClient` and `GreeterService` provide higher-level, more idiomatic Vert.x APIs that are easier to use for most cases.

Additionally, when `grpc-io=true` is enabled, the plugin generates:

[cols="2,4,1", options="header"]
|===
|Generated File |Description |Details

|`GreeterGrpcIo.java`
|Compatibility layer for using the service with standard `io.grpc` stubs and existing gRPC/IO ecosystem
|<<idiomatic-server-io,gRPC/IO Server>> / <<idiomatic-client-io,gRPC/IO Client>>
|===
