[[vertx-grpc-protoc-plugin]]
== Vert.x gRPC Protoc Plugin 2

The easiest way to start using Vert.x gRPC is to utilize its built-in code generator plugin. To do so,
one must define the protocol in the `protobuffer` format as required by gRPC.

[source,proto]
----
syntax = "proto3";

option java_multiple_files = true;
option java_package = "examples";
option java_outer_classname = "HelloWorldProto";
package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
----

This is a very simple example showing the single request, single response mode.

=== Compile the RPC definition

Using the definition above we need to compile it.

You can compile the proto file using the `protoc` compiler if you https://github.com/google/protobuf/tree/master/java#installation---without-maven[like], or you can integrate it in your build.

If you're using Apache Maven you need to add the plugin:

[source,xml]
----
<plugin>
  <groupId>org.xolstice.maven.plugins</groupId>
  <artifactId>protobuf-maven-plugin</artifactId>
  <version>0.6.1</version>
  <configuration>
    <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}</protocArtifact>
    <pluginId>grpc-java</pluginId>
    <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>
    <protocPlugins>
      <protocPlugin>
        <id>vertx-grpc-protoc-plugin2</id>
        <groupId>io.vertx</groupId>
        <artifactId>vertx-grpc-protoc-plugin2</artifactId>
        <version>${stack.version}</version>
        <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
      </protocPlugin>
    </protocPlugins>
  </configuration>
  <executions>
    <execution>
      <id>compile</id>
      <configuration>
        <outputDirectory>${project.basedir}/src/main/java</outputDirectory>
        <clearOutputDirectory>false</clearOutputDirectory>
      </configuration>
      <goals>
        <goal>compile</goal>
        <goal>compile-custom</goal>
      </goals>
    </execution>
  </executions>
</plugin>
----

The plugin configuration includes:

1. **Protocol Buffer compiler artifact** (`protocArtifact`) - Required for compiling `.proto` files into Java classes
2. **gRPC Java plugin** (`pluginId` and `pluginArtifact`) - Generates standard gRPC Java stubs, essential when using the `--grpc-io` option
3. **Vert.x gRPC plugin** (`protocPlugins`) - Generates Vert.x-specific gRPC client and service classes
4. **Output configuration** - Specifies where generated Java files will be placed (`src/main/java`)
5. **Compilation goals** - Defines which Maven goals to execute (`compile` and `compile-custom`)

For more details, see the https://www.xolstice.org/protobuf-maven-plugin/[xolstice protobuf-maven-plugin documentation].

The `${os.detected.classifier}` property is used to make the build OS independent, on OSX it is replaced
by _osx-x86_64_ and so on. To use it you need to add the os-maven-plugin[https://github.com/trustin/os-maven-plugin]
in the `build` section of your `pom.xml`:

[source,xml]
----
<build>
  ...
  <extensions>
    <extension>
      <groupId>kr.motd.maven</groupId>
      <artifactId>os-maven-plugin</artifactId>
      <version>1.4.1.Final</version>
    </extension>
  </extensions>
  ...
</build>
----

This plugin will compile your proto files under `src/main/proto` and make them available to your project.

By default, the plugin generates both client and service files. If you need only one side you can configure the generator to generate only a specific class:

[source,xml]
----
<protocPlugin>
  <id>vertx-grpc-protoc-plugin2</id>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-protoc-plugin2</artifactId>
  <version>${stack.version}</version>
  <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
  <args>
    <arg>--grpc-client</arg>
  </args>
</protocPlugin>
----

=== Alternative Plugin Configuration

Alternatively, you can use the newer `io.github.ascopes` protobuf plugin:

[source,xml]
----
<plugin>
    <groupId>io.github.ascopes</groupId>
    <artifactId>protobuf-maven-plugin</artifactId>
    <version>${ascopes.grpc.version}</version>
    <configuration>
        <protocVersion>${protobuf.version}</protocVersion>
    </configuration>
    <executions>
        <execution>
            <id>compile-java</id>
            <configuration>
                <jvmMavenPlugins>
                    <jvmMavenPlugin>
                        <groupId>io.vertx</groupId>
                        <artifactId>vertx-grpc-protoc-plugin2</artifactId>
                        <version>${vertx.version}</version>
                        <mainClass>io.vertx.grpc.plugin.VertxGrpcGenerator</mainClass>
                        <jvmArgs>
                            <jvmArg>--grpc-client=false</jvmArg>
                        </jvmArgs>
                    </jvmMavenPlugin>
                </jvmMavenPlugins>
            </configuration>
        </execution>
    </executions>
</plugin>
----

This plugin uses `protocVersion` instead of platform-specific artifacts and takes care of downloading protoc based on your platform and version on its own.

For more details, see the https://ascopes.github.io/protobuf-maven-plugin/[ascopes protobuf-maven-plugin documentation].

=== Arguments:

- _--grpc-client_: generate the client files
- _--grpc-service_: generate the service files
- _--grpc-io_: generate stub files compatible with `io.grpc:grpc-stub`, not generated by default. When using this option, you must also ensure the grpc-java plugin is configured (as shown in the Maven configuration above)
- _--grpc-transcoding_: whether to generate transcoding options for methods with HTTP annotations
- _--vertx-codegen_: whether to add Vert.x annotations to the generated classes (`@VertxGen`) By default, this is disabled
- _--service-prefix_: generate service classes with a prefix. For example, if you set it to `MyService`, the generated service class will be `MyServiceGreeterService` instead of `GreeterService`.
- _--help_: show help message
- _--version_: show version information

If no specific generation options are provided, both client and service files will be generated by default. By default, all extensions (currently only 'http') are supported.

If you're using Gradle you need to add the plugin:

[source,groovy]
----
...
apply plugin: 'com.google.protobuf'
...
buildscript {
  ...
  dependencies {
    // ASSUMES GRADLE 2.12 OR HIGHER. Use plugin version 0.7.5 with earlier gradle versions
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
  }
}
...
protobuf {
  protoc {
    artifact = 'com.google.protobuf:protoc:3.2.0'
  }
  plugins {
    grpc {
      artifact = "io.grpc:protoc-gen-grpc-java:1.25.0"
    }
    vertx {
      artifact = "io.vertx:vertx-grpc-protoc-plugin2:${vertx.grpc.version}"
    }
  }
  generateProtoTasks {
    all()*.plugins {
      grpc
      vertx
    }
  }
}
----

This plugin will compile your proto files under `build/generated/source/proto/main` and make them available to your project.

NOTE: the generator plugin is tech preview and can be subject to changes

=== Generated RPC files

For each service definition, the plugin creates several Java RPC files, let's have a quick look at them:

- `examples/Greeter.java`
- `examples/GreeterClient.java`
- `examples/GreeterService.java`
- `examples/GreeterGrpcClient.java`
- `examples/GreeterGrpcService.java`
