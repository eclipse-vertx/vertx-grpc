== Vert.x gRPC Server

Vert.x gRPC Server is a gRPC server powered by Vert.x HTTP server superseding the integrated Netty based gRPC client.

This server provides a gRPC request/response oriented API as well as a generated stub approach with the Vert.x gRPC Generator.

=== Using Vert.x gRPC Server

To use Vert.x gRPC Server, add the following dependency to the _dependencies_ section of your build descriptor:

[tabs]
====
pom.xml::
+
[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-server</artifactId>
  <version>${maven.version}</version>
</dependency>
----

build.gradle::
+
[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'io.vertx:vertx-grpc-server:${maven.version}'
}
----
====


=== Creating a gRPC server

A `{@link io.vertx.grpc.server.GrpcServer}` is a `Handler<HttpServerRequest>` and can be used as an HTTP server request handler.

[source,java]
----
{@link examples.GrpcServerExamples#createServer}
----

A `GrpcServer` can be used within a Vert.x Web router:

[source,java]
----
route.consumes("application/grpc").handler(rc -> grpcServer.handle(rc.request()));
----

[[idiomatic-server]]
=== Idiomatic server stub generation

The <<vertx-grpc-protoc-plugin,Vert.x gRPC protoc plugin>> generates idiomatic service stubs:

- `examples/Greeter.java`
- `examples/GreeterService.java`
- `examples/GreeterGrpcService.java`

The `Greeter` interface defines the primary _contract_ of the service:

[source,java]
----
public interface Greeter {

  Future<examples.grpc.HelloReply> sayHello(examples.grpc.HelloRequest request);

}
----

The `GreeterService` class implements the `Greeter` contract:

[source,java]
----
public class GreeterService implements Greeter {

  public Future<examples.grpc.HelloReply> sayHello(examples.grpc.HelloRequest request) {
    // ...
  }

  protected void sayHello(examples.grpc.HelloRequest request, Completable<examples.grpc.HelloReply> response) {
    // ...
  }
}
----

Usually, you extend this class to provide a service implementation.

The `GreeterGrpcService` class extends `GreeterService` and let you turn your service implementation into a gRPC service
that can be bound to a Vert.x gRPC server:

[source,java]
----
GreeterGrpcService service = GreeterGrpcService.create(new GreeterService() {
  @Override
  public Future<HelloReply> sayHello(HelloRequest request) {
    return Future.succeededFuture(HelloReply.newBuilder()
      .setMessage("Hello " + request.getName())
      .build());
  }
});

grpcServer.add(service);
----

Each service method comes in two flavors, you can override the method you like depending on the style.

==== Unary methods

Unary methods return a Vert.x `Future`

[source,java]
----
{@link examples.GrpcServerExamples#unaryStub1}
----

or process a Vert.x `Promise`

[source,java]
----
{@link examples.GrpcServerExamples#unaryStub2}
----

In both case you need to bind the stub to an existing `GrpcServer`

[source,java]
----
{@link examples.GrpcServerExamples#unaryStub3}
----

==== Streaming requests

Streaming requests are implemented with a `ReadStream`:

[source,java]
----
{@link examples.GrpcServerExamples#streamingRequestStub}
----

==== Streaming responses

Streaming responses are implemented with Vert.x streams and comes in two flavors.

You can return a Vert.x `ReadStream` and let the service send it for you:

[source,java]
----
{@link examples.GrpcServerExamples#streamingResponseStub1}
----

or you can process a `WriteStream`:

[source,java]
----
{@link examples.GrpcServerExamples#streamingResponseStub2}
----

=== Server request/response API

The gRPC request/response server API provides an alternative way to interact with a client without the need of extending
a Java class.

==== Binding a gRPC service method

You will use a `{@link io.vertx.grpc.common.ServiceMethod}` to bind a gRPC service method

[source,java]
----
{@link examples.GrpcServerExamples#createServiceMethod}
----

However, most of the time you will use `ServiceMethod` constants generated by the <<vertx-grpc-protoc-plugin,Vert.x gRPC protoc plugin>>:

[source,java]
----
{@link examples.GrpcServerExamples#reuseServiceMethod}
----

==== Request/response

Each service method is processed by a handler, the handler is bound using a `{@link io.vertx.grpc.common.ServiceMethod}`.

[source,java]
----
{@link examples.GrpcServerExamples#requestResponse}
----

==== Streaming request

You can set handlers to process request events

[source,java]
----
{@link examples.GrpcServerExamples#streamingRequest}
----

==== Streaming response

A streaming response involves calling `{@link io.vertx.grpc.server.GrpcServerResponse#write}` for each element of the stream
and using `{@link io.vertx.grpc.server.GrpcServerResponse#end()}` to end the stream

[source,java]
----
{@link examples.GrpcServerExamples#streamingResponse}
----

==== Bidi request/response

A bidi request/response is simply the combination of a streaming request and a streaming response

[source,java]
----
{@link examples.GrpcServerExamples#bidi}
----

=== gRPC protocols

==== HTTP/2 protocol

The default protocol served by the Vert.x gRPC server is HTTP/2.

In addition, Vert.x gRPC server also supports https://github.com/grpc/grpc-web[gRPC-Web] protocol and HTTP/JSON transcoding.

==== gRPC-Web protocol

The Vert.x gRPC Server supports the gRPC-Web protocol by default.

If your website server and the gRPC server are different, you have to configure the gRPC server for CORS.
This can be done with a Vert.x Web router and the CORS handler:

[source,java]
----
CorsHandler corsHandler = CorsHandler.create()
  .addRelativeOrigin("https://www.mycompany.com")
  .allowedHeaders(Set.of("keep-alive","user-agent","cache-control","content-type","content-transfer-encoding","x-custom-key","x-user-agent","x-grpc-web","grpc-timeout"))
  .exposedHeaders(Set.of("x-custom-key","grpc-status","grpc-message"));
router.route("/com.mycompany.MyService/*").handler(corsHandler);
----

==== gRPC Transcoding

The Vert.x gRPC server supports <<grpc-transcoding,gRPC transcoding>> that enables mapping between HTTP/JSON requests and gRPC services.

==== Protocol configuration

By default, a gRPC server accepts all protocols.

To disable a specific protocol support, configure options with {@link io.vertx.grpc.server.GrpcServerOptions#removeEnabledProtocol} and then create a server with {@link io.vertx.grpc.server.GrpcServer#server(io.vertx.core.Vertx, io.vertx.grpc.server.GrpcServerOptions) GrpcServer#server(vertx, options)}.

.Removing gRPC-Web support
[source,java]
----
{@link examples.GrpcServerExamples#disablingGrpcWeb}
----

=== Flow control

Request and response are back pressured Vert.x streams.

You can pause/resume/fetch a request

[source,java]
----
{@link examples.GrpcServerExamples#requestFlowControl}
----

You can check the writability of a response and set a drain handler

[source,java]
----
{@link examples.GrpcServerExamples#responseFlowControl}
----

=== Timeout and deadlines

The gRPC server handles timeout and deadlines.

Whenever the service receives a request indicating a timeout, the timeout can be retrieved.

[source,java]
----
{@link examples.GrpcServerExamples#checkTimeout}
----

By default, the server

- does not schedule automatically a deadline for a given request
- does not automatically propagate the deadline to a vertx client

The server can schedule deadlines: when a request carries a timeout, the server schedules
locally a timer to cancel the request when the response has not been sent in time.

The server can propagate deadlines: when a request carries a timeout, the server calculate the deadline
and associate the current server request with this deadline. Vert.x gRPC client can use this deadline to compute
a timeout to be sent and cascade the timeout to another gRPC server.

[source,java]
----
{@link examples.GrpcServerExamples#deadlineConfiguration}
----

=== JSON wire format

gRPC implicitly assumes the usage of the https://protobuf.dev[Protobuf] wire format.

The Vert.x gRPC server supports the JSON wire format as well, that is gRPC requests carrying the `application/grpc+json` content type.

The `com.google.protobuf:protobuf-java-util` library performs the JSON encoding/decoding.

Anemic JSON is also supported with Vert.x `JsonObject`

[source,java]
----
{@link examples.GrpcServerExamples#anemicJson}
----

=== Compression

You can compress response messages by setting the response encoding *prior* before sending any message.

Before setting the encoding, you should use {@link io.vertx.grpc.server.GrpcServerResponse#acceptedEncodings()} to ensure
the client RPC supports the encoding algorithm.

[source,java]
----
{@link examples.GrpcServerExamples#responseCompression}
----

NOTE: Compression is not supported over the gRPC-Web protocol.

=== Decompression

Decompression is done transparently by the server when the client send encoded requests.

NOTE: Decompression is not supported over the gRPC-Web protocol.

=== Message level API

The server provides a message level API to interact directly with protobuf encoded gRPC messages.

TIP: the server message level API can be used with the client message level API to write a gRPC reverse proxy

Such API is useful when you are not interested in the content of the messages, and instead you want to forward them to
another service, e.g. you are writing a proxy.

[source,java]
----
{@link examples.GrpcServerExamples#protobufLevelAPI}
----

You can also set a `messageHandler` to handle `{@link io.vertx.grpc.common.GrpcMessage}`, such messages preserve the
client encoding, which is useful the service you are forwarding to can handle compressed messages directly, in this case
the message does not need to be decompressed and compressed again.

[source,java]
----
{@link examples.GrpcServerExamples#messageLevelAPI}
----

The `{@link io.vertx.grpc.server.GrpcServerResponse#writeMessage}` and `{@link io.vertx.grpc.server.GrpcServerResponse#endMessage}` will
handle the message encoding:

- when the message uses the response encoding, the message is sent as is
- when the message uses a different encoding, it will be encoded, e.g. compressed or uncompressed

=== gRPC Reflection service

Support for the https://grpc.io/docs/guides/reflection/[gRPC reflection service] can be added to your Vert.x gRPC Server.

To use the Reflection service, add the following dependency:

[tabs]
====
pom.xml::
+
[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-reflection</artifactId>
  <version>${maven.version}</version>
</dependency>
----

build.gradle::
+
[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'io.vertx:vertx-grpc-reflection:${maven.version}'
}
----
====

You can then deploy the reflection service in your server:

[source,java]
----
{@link examples.GrpcServerExamples#reflectionExample}
----

=== gRPC Health service

The gRPC Health service implements the standard https://github.com/grpc/grpc/blob/master/doc/health-checking.md[gRPC health checking protocol], which allows clients to check the health status of your services.

By default `HealthService` returns all registered services with status `SERVING`, if you want to override this, you need to register health check, for the specified service.

The Health service provides a simple way to expose health status of your services via gRPC.
It implements two RPCs:

* `Check`: For checking the health status of a service
* `List`: For listing services and their health status
* `Watch`: For watching the health status of a service over time

To use the Health Service, add the following dependency:

[tabs]
====
pom.xml::
+
[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>io.vertx</groupId>
  <artifactId>vertx-grpc-health</artifactId>
  <version>${maven.version}</version>
</dependency>
----

build.gradle::
+
[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'io.vertx:vertx-grpc-health:${maven.version}'
}
----
====

Here's how to create and bind a Health service to your gRPC server:

[source,java]
----
{@link examples.GrpcServerExamples#healthServiceExample}
----

Clients can then check the health of your services using the standard gRPC health checking protocol.

NOTE: health check service is in tech preview in Vert.x 5.0 until the API becomes stable.
